<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/vlasiator_manual/libs/highlight/github.min.css"> <link rel=stylesheet  href="/vlasiator_manual/css/jtd.css"> <link rel=icon  href="/vlasiator_manual/assets/favicon.ico"> <title>Installation</title> <div class=page-wrap > <div class=side-bar > <div class=header > <a href="/vlasiator_manual/" class=title > Vlasiator </a> </div> <label for=show-menu  class=show-menu >MENU</label> <input type=checkbox  id=show-menu  role=button > <div class=menu  id=side-menu > <ul class=menu-list > <li class="menu-list-item "><a href="/vlasiator_manual/" class="menu-list-link ">Home</a> <li class="menu-list-item active"><a href="/vlasiator_manual/menu1/" class="menu-list-link active">Installation</a> <ul class="menu-list-child-list "> <li class="menu-list-item "><a href="/vlasiator_manual/menu1/#dccrg" class=menu-list-link >DCCRG</a> <li class="menu-list-item "><a href="/vlasiator_manual/menu1/#zoltan" class=menu-list-link >Zoltan</a> <li class="menu-list-item "><a href="/vlasiator_manual/menu1/#boost" class=menu-list-link >Boost</a> <li class="menu-list-item "><a href="/vlasiator_manual/menu1/#eigen" class=menu-list-link >Eigen</a> <li class="menu-list-item "><a href="/vlasiator_manual/menu1/#jemalloc" class=menu-list-link >Jemalloc</a> <li class="menu-list-item "><a href="/vlasiator_manual/menu1/#phiprof" class=menu-list-link >PhiProf</a> <li class="menu-list-item "><a href="/vlasiator_manual/menu1/#papi" class=menu-list-link >Papi</a> </ul> <li class="menu-list-item "><a href="/vlasiator_manual/menu2/" class="menu-list-link ">Run</a> <li class="menu-list-item "><a href="/vlasiator_manual/menu3/" class="menu-list-link ">Postprocessing</a> <li class="menu-list-item "><a href="/vlasiator_manual/menu4/" class="menu-list-link ">Internal</a> <ul class="menu-list-child-list "> <li class="menu-list-item "><a href="/vlasiator_manual/menu4/#sysboundary" class=menu-list-link >SysBoundary</a> <li class="menu-list-item "><a href="/vlasiator_manual/menu4/#vlasov_solver" class=menu-list-link >Vlasov Solver</a> </ul> <li class="menu-list-item "><a href="/vlasiator_manual/menu5/" class="menu-list-link ">Test</a> <li class="menu-list-item "><a href="/vlasiator_manual/menu6/" class="menu-list-link ">Misc</a> <li class="menu-list-item "><a href="/vlasiator_manual/menu7/" class="menu-list-link ">Method</a> <li class="menu-list-item "><a href="/vlasiator_manual/menu8/" class="menu-list-link ">Trouble Shooting</a> </ul> </div> <div class=footer > This is <em>Just the docs</em>, adapted from the <a href="https://github.com/pmarsceill/just-the-docs" target=_blank >Jekyll theme</a>. </div> </div> <div class=main-content-wrap > <div class=main-content > <div class=main-header > <a id=github  href="/vlasiator_manual//github.com/fmihpc/vlasiator">Vlasiator on GitHub</a> </div> <div class=franklin-content ><h1 id=installation ><a href="#installation" class=header-anchor >Installation</a></h1> <div class=franklin-toc ><ol><li><a href="#a_brief_history_of_the_build_system">A Brief History of the Build System</a><ol><li><a href="#even_better_approach">Even better approach</a></ol><li><a href="#dccrg">DCCRG</a><ol><li><a href="#pros_cons">Pros &amp; Cons</a></ol><li><a href="#zoltan">Zoltan</a><li><a href="#boost">Boost</a><li><a href="#eigen">Eigen</a><li><a href="#vectorclass">Vectorclass</a><li><a href="#phiprof">PHIPROF</a><li><a href="#jemalloc">JEMALLOC</a><li><a href="#papi">PAPI</a></ol></div> <h2 id=a_brief_history_of_the_build_system ><a href="#a_brief_history_of_the_build_system" class=header-anchor >A Brief History of the Build System</a></h2> <p>There are several issues with the current file system:</p> <ul> <li><p>Source files should not be present on the top level.</p> <li><p>External library linking is a nightmare if you start on a new machine.</p> <li><p>The Makefile lists every single source file with repetitive flags. The flags and preprocessor settings are buried in the long Makefile which makes it hard to modify if necessary.</p> <li><p>Vlasiator depends on many packages. It takes a huge effort to install the code on a new machine, mainly due to the dependency hell.</p> </ul> <p>To handle the fore-mentioned problems, I propose three major changes:</p> <ol> <li><p>Reorganize the file levels.</p> <li><p>Rewrite the Makefile.</p> <li><p>Add a new configuration file.</p> </ol> <p>I have come across several round of modification trying to make the new build system simple and useful.</p> <ol> <li><p>For a fresh new machine,</p> </ol> <pre><code class="shell hljs">./configure.py -h</code></pre>
<p>shows the available options. By default options with prefix <code>-</code> require no arguments, and options with prefix <code>--</code> require one argument.</p>
<pre><code class="shell hljs">./configure.py -install</code></pre>
<p>tries to install all the dependencies in the new <code>lib</code> folder except Boost. On Ubuntu it is often installed under the default folder; on supercomputers there is usually a module to load.</p>
<ol start=2 >
<li><p>To access an existing customized Makefile in <code>MAKE</code> folder with library paths and compiler flags, e.g.</p>

</ol>
<pre><code class="shell hljs">./configure.py --machine=yann</code></pre>
<p>then it will include the preset library paths in the main Makefile. By default it links to <code>MAKE/Makefile.default</code>.</p>
<ol start=3 >
<li><p>To quickly setup the library paths on a new machine, you create a new makefile <code>MAKE/Makefile.yours</code> and set the required links.</p>

</ol>
<p>Then this can be called with <code>./configure.py --machine&#61;yours</code>.</p>
<p>I still keep the options of changing order of solvers, floating point precisions, etc.. Even though they rarely change, it is still changeable, but the default is set to the most common options.</p>
<p>I do not provide support for python2, since the official support has also ended by the end of 2020. It will warn you about obsolete python version.</p>
<p>The tools should in principle also be able to be compiled, but for now it is not guaranteed to work.</p>
<p>This comes together with a new Makefile borrowed from Athena. I need to think about whether or not we should use a hierarchical Makefile architecture.</p>
<h3 id=even_better_approach ><a href="#even_better_approach" class=header-anchor >Even better approach</a></h3>
<p>CMake-like tools will make your life much easier.</p>
<h2 id=dccrg ><a href="#dccrg" class=header-anchor >DCCRG</a></h2>
<p>DCCRG is the underlying grid and MPI library for Vlasiator. It provides similar functionality compared to <strong>AMReX</strong> and <strong>BATL</strong>.</p>
<h3 id=pros_cons ><a href="#pros_cons" class=header-anchor >Pros &amp; Cons</a></h3>
<p>Pros:</p>
<ul>
<li><p>Simplicity. Given the grid size on the base level, each positive integer corresponds to a unique cell index on any refinement level.</p>

<li><p>Localization. There is no need for global information to know the location of a given cell or the neighboring cell indexes.</p>

</ul>
<p>Cons:</p>
<ul>
<li><p>It is purely cell-based, which makes any spatial-related computation slow</p>

<li><p>It is purely based on MPI, without considering multithreading or hetergeneous architectures.</p>

</ul>
<h2 id=zoltan ><a href="#zoltan" class=header-anchor >Zoltan</a></h2>
<p>Zoltan is used to do loading balancing, or spatial partitioning of the computation.</p>
<p>It can be downloaded and installed from Sandia&#39;s server.</p>
<pre><code class="shell hljs">git clone git@github.com:sandialabs/Zoltan.git
mkdir zoltan-build
cd zoltan-build
../Zoltan/configure --prefix=&quot;current_working_directory/zoltan&quot; --enable-mpi --with-mpi-compilers=yes --with-gnumake --with-id-type=ullong CC=mpicc CXX=mpicxx
make -j 4
make install
cd ..
rm -r zoltan-build</code></pre>
<p>It worked smoothly on my local Ubuntu, but not on the cluster Mahti in my first attempt. It worked on Pleiades in my first attempt.</p>
<h2 id=boost ><a href="#boost" class=header-anchor >Boost</a></h2>
<p>Boost is used in Vlasiator solely for argument parsing &#40;<code>Boost.Program_options</code>&#41;. It is typically installed as a HPC module. If not, download it from <a href="https://www.boost.org/">boost.org</a> and follow the installation instructions.</p>
<h2 id=eigen ><a href="#eigen" class=header-anchor >Eigen</a></h2>
<p>Eigen is used for linear algebra, but I don&#39;t know where exactly it is used in Vlasiator.</p>
<p>Assuming you are on the top level and want to install Eigen under directory <code>lib</code>,</p>
<pre><code class="shell hljs">wget https://gitlab.com/libeigen/eigen/-/archive/3.2.8/eigen-3.2.8.tar.bz2
tar -xf eigen-3.2.8.tar.bz2
cp -r eigen-3.2.8/Eigen lib</code></pre>
<p>However, the latest Eigen version 3.3.8 has compilation error in assertions:</p>
<pre><code class="shell hljs">3.3.8
/home/hyzhou/include/Eigen/src/Core/products/Parallelizer.h:162:40: error: ‘eigen_assert_exception’ is not a member of ‘Eigen’
  162 |   if (errorCount) EIGEN_THROW_X(Eigen::eigen_assert_exception());
      |                                        ^~~~~~~~~~~~~~~~~~~~~~
/home/hyzhou/include/Eigen/src/Core/util/Macros.h:1017:34: note: in definition of macro ‘EIGEN_THROW_X’</code></pre>
<h2 id=vectorclass ><a href="#vectorclass" class=header-anchor >Vectorclass</a></h2>
<p>Vectorclass used for some avx instructions in the acceleration part of the Vlasov solver.</p>
<p>Assuming you are on the top level and want to install Vectorclass under directory <code>lib</code>,</p>
<pre><code class="shell hljs">git clone https://github.com/vectorclass/version1.git
git clone https://github.com/vectorclass/add-on.git
cp add-on/vector3d/vector3d.h version1/
mv version1 lib/vectorclass</code></pre>
<p>There are two versions in-use:</p>
<ul>
<li><p>AGNER, which aims at ultimate avx performance;</p>

<li><p>FALLBACK, which is homemade and more robust, but does not provide the best performance.</p>

</ul>
<h2 id=phiprof ><a href="#phiprof" class=header-anchor >PHIPROF</a></h2>
<p><em>PHIPROF</em> is the profiler library used, which is very similar to the timer library in SWMF written in Fortran.</p>
<pre><code class="shell hljs">git clone https://github.com/fmihpc/phiprof
cd phiprof/src
make clean
make -j 4
cd ../..</code></pre>
<p>Currently I need to load the dynamic library like this:</p>
<pre><code class="shell hljs">export LD_LIBRARY_PATH=/home/hongyang/Vlasiator/vlasiator/lib/phiprof/lib</code></pre>
<p>Alternatively, you can use <code>rpath</code> to insert the path into the executable, as has been done on Vorna.</p>
<p>PHIPROF write outputs to <code>phiprof_x.txt</code>, and they get overwritten every diagnostic interval.</p>
<h2 id=jemalloc ><a href="#jemalloc" class=header-anchor >JEMALLOC</a></h2>
<p><em>JEMALLOC</em> is a library for memory allocation, as an alternative to the standard C allocator <em>glibc</em>. Rumour has it that Firefox is also using this library to reduce the memory fragmentation during heap allocations. However, if this is consistently performing better in all aspects than the standard allocator function <code>malloc</code>, then this would become the standard allocator instead. So apparently it comes with some other drawbacks or trade-offs. From <a href="https://stackoverflow.com/questions/13027475/cpu-and-memory-usage-of-jemalloc-as-compared-to-glibc-malloc">an interesting post on StackOverflow</a>:</p>
<blockquote>
<p>If you have reasons to think that your application memory management is not effective because of fragmentation, you have to make tests. It is the only reliable information source for your specific needs. If jemalloc is always better that glibc, glibc will make jemalloc its official allocator. If glibc is always better, jemalloc will stop to exist. When competitors exist long time in parallel, it means that each one has its own usage niche.</p>
</blockquote>
<p>When you search on the web, you will find all kinds of confusing results. The proper way is to test for our case. One interesting finding is that a MPI communication bug in Vlasiator&#39;s DCCRG call will only be triggered by JEMALLOC, at least in some small scale tests.</p>
<pre><code class="shell hljs">wget https://github.com/jemalloc/jemalloc/releases/download/4.0.4/jemalloc-4.0.4.tar.bz2
tar -xf jemalloc-4.0.4.tar.bz2
cd jemalloc-4.0.4
./configure --prefix=&quot;current_working_directory/jemalloc&quot; --with-jemalloc-prefix=&quot;je_&quot;
make
make install</code></pre>
<p>This is also a dynamic library that needs to be loaded:</p>
<pre><code class="julia hljs"><span class=hljs-keyword >export</span> LD_LIBRARY_PATH=/home/hongyang/Vlasiator/vlasiator/lib/jemalloc/lib</code></pre>
<p>On a cluster, we may also choose to set <code>rpath</code>.</p>
<h2 id=papi ><a href="#papi" class=header-anchor >PAPI</a></h2>
<p><a href="http://icl.cs.utk.edu/papi/">PAPI</a> is a memory tracker, activated only when <code>-DPAPI_MEM</code> is added to the compiler flags.</p>
<pre><code class="shell hljs">git clone https://bitbucket.org/icl/papi.git
cd papi/src/
./configure --prefix=&quot;current_working_directory/papi&quot; CC=mpicc CXX=mpicxx
make -j 4
make install</code></pre>
<p>A typical output of PAPI in Vlasiator looks like the following</p>
<pre><code class="julia hljs">(MEM) Resident per node (avg, min, max): <span class=hljs-number >150.348</span> <span class=hljs-number >144.319</span> <span class=hljs-number >161.92</span>
(MEM) High water mark per node (GiB) avg: <span class=hljs-number >201.933</span> min: <span class=hljs-number >185.869</span> max: <span class=hljs-number >217.764</span> sum (TiB): <span class=hljs-number >5.91601</span> on <span class=hljs-number >30</span> nodes</code></pre>
<p>The resident is how much the code uses when the memory report is done. High water mark is the highest it has been<sup id="fnref:1"><a href="#fndef:1" class=fnref >[1]</a></sup>. These differ because the memory usage is very dynamic with blocks being added and then removed in acceleration and block adjustment.</p>
<p><table class=fndef  id="fndef:1">
    <tr>
        <td class=fndef-backref ><a href="#fnref:1">[1]</a>
        <td class=fndef-content >So this is different from high water mark in Linux kernel.
    
</table>
 MPI communication requires memory buffers where to store received data. These are for the neighbor spatial cells which are empty right after the restart. After the first step with communication they have been initialized and contain block data representing the neighboring cells., therefore the numbers will be larger than the first report after restart, e.g. by a factor of ~30&#37;.</p>
<div class=page-foot >
  <div class=copyright >
    &copy; Hongyang Zhou. Last modified: April 16, 2023. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
  </div>
</div>
</div>
    </div> 
    </div> 
    </div> <!-- end of class page-wrap-->