<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/vlasiator_manual/libs/highlight/github.min.css"> <link rel=stylesheet  href="/vlasiator_manual/css/jtd.css"> <link rel=icon  href="/vlasiator_manual/assets/favicon.ico"> <title>Internal</title> <div class=page-wrap > <div class=side-bar > <div class=header > <a href="/vlasiator_manual/" class=title > Vlasiator </a> </div> <label for=show-menu  class=show-menu >MENU</label> <input type=checkbox  id=show-menu  role=button > <div class=menu  id=side-menu > <ul class=menu-list > <li class="menu-list-item "><a href="/vlasiator_manual/" class="menu-list-link ">Home</a> <li class="menu-list-item "><a href="/vlasiator_manual/menu1/" class="menu-list-link ">Installation</a> <li class="menu-list-item "><a href="/vlasiator_manual/menu2/" class="menu-list-link ">Run</a> <li class="menu-list-item "><a href="/vlasiator_manual/menu3/" class="menu-list-link ">Postprocessing</a> <li class="menu-list-item active"><a href="/vlasiator_manual/menu4/" class="menu-list-link active">Internal</a> <li class="menu-list-item active"><a href="/vlasiator_manual/menu5/" class="menu-list-link ">Misc</a> <ul class="menu-list-child-list "> <li class="menu-list-item "><a href="#" class=menu-list-link >Submenu</a> </ul> </ul> </div> <div class=footer > This is <em>Just the docs</em>, adapted from the <a href="https://github.com/pmarsceill/just-the-docs" target=_blank >Jekyll theme</a>. </div> </div> <div class=main-content-wrap > <div class=main-content > <div class=main-header > <a id=github  href="/vlasiator_manual//github.com/fmihpc/vlasiator">Vlasiator on GitHub</a> </div> <div class=franklin-content ><h1 id=internal_code_structure ><a href="#internal_code_structure">Internal Code Structure</a></h1> <p>In C&#43;&#43;, the included files should be ordered and grouped. This part can be done with an automatic script. It should be able to:</p> <ul> <li><p>Correct function and file names according to naming standard &#40;<code>.hpp → .h</code>, <code>datareducer → dataReducer</code>&#41;</p> <li><p>Switch orders of #include if required</p> <li><p>Correct comments indentation and argument indentations.</p> </ul> <p>I need to go through the coding standard.</p> <h2 id=main ><a href="#main">Main</a></h2> <code>vlasiator.cpp</code> <pre><code class="cpp hljs"><span class=hljs-meta >#<span class=hljs-meta-keyword >include</span> <span class=hljs-meta-string >&lt;cstdlib&gt;</span></span>
<span class=hljs-meta >#<span class=hljs-meta-keyword >include</span> <span class=hljs-meta-string >&lt;iostream&gt;</span></span>
<span class=hljs-meta >#<span class=hljs-meta-keyword >include</span> <span class=hljs-meta-string >&lt;cmath&gt;</span></span>
<span class=hljs-meta >#<span class=hljs-meta-keyword >include</span> <span class=hljs-meta-string >&lt;vector&gt;</span></span>
<span class=hljs-meta >#<span class=hljs-meta-keyword >include</span> <span class=hljs-meta-string >&lt;sstream&gt;</span></span>
<span class=hljs-meta >#<span class=hljs-meta-keyword >include</span> <span class=hljs-meta-string >&lt;ctime&gt;</span></span>
<span class=hljs-meta >#<span class=hljs-meta-keyword >ifdef</span> _OPENMP</span>
   <span class=hljs-meta >#<span class=hljs-meta-keyword >include</span> <span class=hljs-meta-string >&lt;omp.h&gt;</span></span>
<span class=hljs-meta >#<span class=hljs-meta-keyword >endif</span></span>

<span class=hljs-meta >#<span class=hljs-meta-keyword >include</span> <span class=hljs-meta-string >&lt;fsgrid.hpp&gt;</span></span>

<span class=hljs-meta >#<span class=hljs-meta-keyword >include</span> <span class=hljs-meta-string >&quot;vlasovmover.h&quot;</span></span>
<span class=hljs-meta >#<span class=hljs-meta-keyword >include</span> <span class=hljs-meta-string >&quot;definitions.h&quot;</span></span>
<span class=hljs-meta >#<span class=hljs-meta-keyword >include</span> <span class=hljs-meta-string >&quot;mpiconversion.h&quot;</span></span>
<span class=hljs-meta >#<span class=hljs-meta-keyword >include</span> <span class=hljs-meta-string >&quot;logger.h&quot;</span></span>
<span class=hljs-meta >#<span class=hljs-meta-keyword >include</span> <span class=hljs-meta-string >&quot;parameters.h&quot;</span></span>
<span class=hljs-meta >#<span class=hljs-meta-keyword >include</span> <span class=hljs-meta-string >&quot;readparameters.h&quot;</span></span>
<span class=hljs-meta >#<span class=hljs-meta-keyword >include</span> <span class=hljs-meta-string >&quot;spatial_cell.hpp&quot;</span></span>
<span class=hljs-meta >#<span class=hljs-meta-keyword >include</span> <span class=hljs-meta-string >&quot;datareduction/datareducer.h&quot;</span></span>
<span class=hljs-meta >#<span class=hljs-meta-keyword >include</span> <span class=hljs-meta-string >&quot;sysboundary/sysboundary.h&quot;</span></span>

<span class=hljs-meta >#<span class=hljs-meta-keyword >include</span> <span class=hljs-meta-string >&quot;fieldsolver/fs_common.h&quot;</span></span>
<span class=hljs-meta >#<span class=hljs-meta-keyword >include</span> <span class=hljs-meta-string >&quot;projects/project.h&quot;</span></span>
<span class=hljs-meta >#<span class=hljs-meta-keyword >include</span> <span class=hljs-meta-string >&quot;grid.h&quot;</span></span>
<span class=hljs-meta >#<span class=hljs-meta-keyword >include</span> <span class=hljs-meta-string >&quot;iowrite.h&quot;</span></span>
<span class=hljs-meta >#<span class=hljs-meta-keyword >include</span> <span class=hljs-meta-string >&quot;ioread.h&quot;</span></span>

<span class=hljs-meta >#<span class=hljs-meta-keyword >include</span> <span class=hljs-meta-string >&quot;object_wrapper.h&quot;</span></span>
<span class=hljs-meta >#<span class=hljs-meta-keyword >include</span> <span class=hljs-meta-string >&quot;fieldsolver/gridGlue.hpp&quot;</span></span></code></pre> <p>Stages:</p> <ol> <li><p><code>Initialization</code></p> </ol> <ul> <li><p><code>Read parameters</code></p> <li><p><code>open logFile &amp; diagnostic</code></p> <li><p><code>Init project</code></p> <li><p><code>Init fieldsolver grids</code></p> <li><p><code>Init grids</code></p> <li><p><code>Init DROs</code></p> <li><p><code>getFieldsFromFsGrid</code></p> <li><p><code>compute-dt</code></p> <li><p><code>write-initial-state</code></p> <li><p><code>compute-dt</code></p> <li><p><code>propagate-velocity-space-dt/2</code></p> </ul> <ol start=2 > <li><p><code>Simulation</code></p> </ol> <ul> <li><p><code>IO</code></p> <ul> <li><p><code>checkExternalCommands</code></p> <li><p><code>logfile-io</code></p> <li><p><code>diagnostic-io</code></p> <li><p><code>write-system</code></p> <li><p><code>Bailout-allreduce</code></p> <li><p><code>compute-is-restart-written-and-extra-LB</code></p> <li><p><code>write-restart</code></p> </ul> <li><p><code>update-dt</code></p> <li><p><code>Propagate</code></p> <ul> <li><p><code>Spatial-space</code>: <code>calculateSpatialTranslation&#40;&#41;</code></p> <li><p><code>Update system boundaries &#40;Vlasov post-translation&#41;</code>: <code>sysBoundaries.applySysBoundaryVlasovConditions&#40;&#41;</code></p> <li><p><code>Compute interp moments</code>: <code>calculateInterpolatedVelocityMoments&#40;&#41;</code></p> <li><p><code>Propagate Fields</code>: <code>propagateFields&#40;&#41;</code></p> <ul> <li><p><code>fsgrid-coupling-in</code></p> <li><p><code>getFieldsFromFsGrid</code></p> </ul> <li><p><code>Velocity-space</code>: <code>calculateAcceleration&#40;&#41;</code></p> <li><p><code>Update system boundaries &#40;Vlasov post-acceleration&#41;</code></p> <li><p><code>Compute interp moments</code></p> </ul> </ul> <ol start=3 > <li><p><code>Finalization</code></p> </ol> <p>Questions:</p> <ul> <li><p><code>object_wrapper.h</code>: it defines a struct named ObjectWrapper which contains the AMR criteria, container for user-defined mesh data, parameters for all particle species, projects, and parameters for velocity meshes.</p> <li><p><code>fieldsolver/gridGlue.hpp</code>: names are not following the same standard&#33;</p> <li><p><code>phiprof.hpp</code></p> </ul> <p>The usage of this profiler is quite similar to Gabor’s library, both of which should be using <code>mpi_wtime</code> on the lower level.</p> <p>During compilation, there is a warning about <code>narrowing conversion of ...</code>. What does it mean and why do we need this?</p> <pre><code class="julia hljs"><span class=hljs-keyword >using</span> namespace phiprof
<span class=hljs-keyword >using</span> namespace std</code></pre> <p>Since they are already imported, there is no need to add <code>std::</code> in the rest of code.</p> <ul> <li><p><code>recalculateLocalCellsCache&#40;&#41;</code>: why do we need another local block for the 2 lines?</p> <li><p>What is “ad” in the following comments? &quot;and&quot;?</p> </ul> <blockquote> <p>needs to be done here already ad the background field will be set right away,</p> </blockquote> <ul> <li><p>As one can see, there are many FsGrid objects, but they now all share some common values like dx, dy, dz, etc. Why do we need separate values of those?</p> <li><p>The cubic spatial cell requirement is to restrict. Users have to calculate it themselves and even if the cells are not cubic the code will only give a warning message but still run. Maybe we should just add something to the kernel functions.</p> <li><p>The comments for initializing data reduction operators are confusing.</p> <li><p>The main loop with while: Phiprof diagnostic output is fixed to 10 steps. We should have the flexibility to change that.</p> <li><p>The condition <code>P::propagateField</code> comments say that it is only for B field? But I can see all the fields in the argument list of propagteFields?</p> <li><p><code>getFieldsFromFsGrid</code>: since the field solver is working on a regular Cartesian grid, this is supposed to copy field results back to dccrg grid for vdf?</p> </ul> <h2 id=definitions ><a href="#definitions">Definitions</a></h2> <ul> <li><p>What should go into <code>common.h</code>, <code>definitions.h</code>, and <code>parameters.h</code> respectively?</p> </ul> <code>definitions.h</code> <ul> <li><p><code>namespace vmesh</code>: doesn’t it look the same with/without AMR? </p> </ul> <p>I have no clue why this local block ID has to be defined here, since it probably only lives in a local scope.</p> <h2 id=common ><a href="#common">Common</a></h2> <code>common.h</code> <p><code>Namespace sysboundarytype</code>: is SET_MAXWELLIAN for the fixed inflow?</p> <h2 id=parameters ><a href="#parameters">Parameters</a></h2> <code>parameters.h</code> <ul> <li><p>Why are there a max and a min CFL number?</p> <li><p>What is the difference between <code>vector&lt;CellID&gt;</code> and <code>vector&lt;CellID&gt;&amp;</code>? Does the second one mean that it is essentially the same vector without copying?</p> </ul> <h2 id=sysboundary ><a href="#sysboundary">SysBoundary</a></h2> <p>The top level file is <code>sysboundarycondition.cpp</code>, with the declaration of <code>namespace SBC</code>. It contains a base class called <code>SysBoundaryCondition</code>, and 4 derived classes:</p> <ul> <li><p><code>DoNotCompute</code></p> <li><p><code>Ionosphere</code></p> <li><p><code>Outflow</code></p> <li><p><code>SetMaxwellian</code></p> </ul> <p>The base class has a private variable <code>sysBoundaryCondList</code> to keep track of all the boundary conditions as strings. This can contain multiple options for the same BC class?</p> <p>The class is declared in the header file. On top of the boundary types class, there is a container class <code>SysBoundary</code> that is used to initialize, store, and apply boundary conditions.</p> <p>In <code>Commons.h</code>, the general information for the grid is defined:</p> <pre><code class="cpp hljs"><span class=hljs-class ><span class=hljs-keyword >struct</span> <span class=hljs-title >technical</span> {</span>
   <span class=hljs-keyword >int</span> sysBoundaryFlag;  <span class=hljs-comment >/*!&lt; System boundary flags */</span>
   <span class=hljs-keyword >int</span> sysBoundaryLayer; <span class=hljs-comment >/*!&lt; System boundary layer index */</span>
   Real maxFsDt;         <span class=hljs-comment >/*!&lt; Maximum timestep allowed in ordinary space by fieldsolver for this cell */</span>
   <span class=hljs-keyword >int</span> fsGridRank;       <span class=hljs-comment >/*!&lt; Rank in the fsGrids cartesian coordinator */</span>
   uint SOLVE;           <span class=hljs-comment >/*!&lt; Bit mask to determine whether a given cell should solve E or B components */</span>
   <span class=hljs-keyword >int</span> refLevel;         <span class=hljs-comment >/*!&lt; AMR Refinement Level */</span>
};</code></pre> <p>The base <code>getParameters&#40;&#41;</code> function is used to set periodic BC or not. This may not be the ideal place to do it. By definition this function should only <em>read</em> parameters without doing anything further.</p> <p><code>initSysBoundaries&#40;&#41;</code>: loops through the list of system boundary conditions listed as to be used in the configuration file/command line arguments. For each of these it adds the corresponding instance and updates the member <code>isThisDynamic</code> to determine whether any <code>SysBoundaryCondition</code> is dynamic in time.</p> <p>This can be modified to remove the periodicity checking, and the boundary list initialization from <code>sysBoundaryCondList</code> is unnecessary. All types of boundary conditions should be prescribed in the class.</p> <p><code>P::xcells_ini</code>: what does this effect?</p> <code>AddSysBoundary&#40;&#41;</code> <code>initSysBoundary&#40;&#41;</code> <p><code>checkRefinement&#40;&#41;</code>: for AMR usage presumably?</p> <p><code>belongsToLayer&#40;&#41;</code>: check ghost cell layers?</p> <p><code>classifyCells&#40;&#41;</code>: loops through all cells and and for each assigns the correct <code>sysBoundaryFlag</code> depending on the return value of each <code>SysBoundaryCondition</code>&#39;s <code>assignSysBoundary</code>.</p> <p><code>applyInitialState&#40;&#41;</code>: loops through all <code>SysBoundaryConditions</code> and calls the corresponding <code>applyInitialState&#40;&#41;</code> function for all existing particle species.</p> <p><code>applySysBoundaryVlasovConditions&#40;&#41;</code>: loops through all <code>SysBoundaryConditions</code> and calls the corresponding <code>vlasovBoundaryCondition&#40;&#41;</code> function for all moments for all particle species, one at a time.</p> <p><code>vlasovBoundaryCopyFromTheClosestNbr&#40;&#41;</code>: the last argument, <code>calculate_V_moments</code> should be renames, as it looks too similar to a function&#33;</p> <div class=page-foot > <div class=copyright > &copy; Hongyang Zhou. Last modified: December 16, 2020. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>. </div> </div> </div> </div> </div> </div> <!-- end of class page-wrap-->